```get_corner_polyhedron()```

# Basic Informations

For an LP min c'x s.t. Ax ≤ b, x ≥ 0 and an basic feasible solution x' and A' the extended matrix (inclusive slack).
Let B denote the set of columns corresponding to the basic variables (inclusive slack) and N the rest of the columns
Then rearrange A' = [B N] and x' = [x_B x_N]. The rows of the optimal tableau is hence given by
$$
 x_i = (B^{-1}b_B)_k - (e_k'B^{-1}N)x_N
$$
where i∈B and k∈[m] the index of the x_i in the basis or equivalently
    (B^{-1}b_B)_k = (e_k'B^{-1})Bx_B + (e_k'B^{-1})Nx_N = e_k'B^{-1}Ax
This equations hold true for any element of the LP feasible set and x' is given by setting all the components of x_N to 0.
So x' satisfy
    x'_i = (B^{-1}b_B)_k
for every i∈B where k is the index of the variable x_i on the basis
Let j∈N we construct x'' by increasing x_j to 1. To stay feasible, we need to adjust each basic variable, that is
    x_i'' = (B^{-1}b_B)_k - (e_k'B^{-1}N)_{kl} for all i in B where k is the index of variable x_i in B and l is the index of j in N
    x_j'' = 1
The ray r_j defined by j is then defined by x''-x'. Concretely
    r_j,i = - (e_k'B{-1}N)_{kl}  for all i in B where k is the index of variable x_i in B and l is the index of j in N
    r_j,j = 1
The corner polyhedron at x' is then given by
    x' + cone(r_k | k∈N)
SCIP generalizes this approach a bit but the intuition is as follow. If a slack is nonbasic, then the corresponding row a_ix = b_i is tight
The ray generated by this slack pushes against this hyperplane towards the feasible zone a_ix <= b_i. Similarly if a variable x_i is nonbasic,
then the variable is zero i.e. x=0. So the ray generated by this variable pushes against the hyperplane x_i = 0 upwards
   